import os
import random
import re
import json
from dotenv import load_dotenv

from openai import OpenAI

tokens = 0

def isVulnerable(cwe, desc, code):
    global tokens
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {
                "role": "user",
                "content": f"""
                    Does the following function contain an obvious {cwe} vulnerability: {desc}?
                    Respond with two lines.
                    The first line should contain a short analysis of the code.
                    The second line should contain one word, either "VULN" or "SAFE" to indicate the status of the code.

                    {code}
                """ 
            }
        ],
        temperature=1,
        stop=[],
    )

    tokens += response.usage.total_tokens

    # divide number of characters in prompt by 4 to get tokes
    tokens += len(code) / 4

    if response.choices[0].message.content.split("\n")[-1] == "VULN":
        return 1
    if response.choices[0].message.content.split("\n")[-1] == "SAFE":
        return 0
    return -1


def calculateTotalCost(tokens):
    # Assuming price upper limit
    pricePerToken = 15 / 1000000
    totalCost = tokens * pricePerToken
    return totalCost

CWE = "CWE-476"
CHAR_LIMIT = 800 # tested using 800 for 476 and 2000 for 120

load_dotenv()
apiKey = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=apiKey)

data = {}
with open("../input/diversevul_2.json", "r") as file:
    data = json.load(file)

cwes = {}
with open("../input/2000.csv", "r", encoding="utf-8") as file:
    cwes = {f"CWE-{line.split(',')[0]}": line.split(",")[1] for line in file.readlines()}

# Filter data to only include items with CWE-125
filtered_data = {k: v for k, v in data.items() if len(v["cwe"]) == 1 and v["cwe"][0] == CWE and sum([1 for i in v["code"] if i["target"] == 1]) == 1}

def getSignature(func):
    try:
        return re.search(r"^[^\)]+\)", func).group(0).replace("\n", "").replace("\t", "").replace(" ", "")
    except:
        return -1

testingData = []

for i in filtered_data:
    for j in filtered_data[i]["code"]:
        if j["target"] == 1:
            vulnSignature = getSignature(j["func"])
            if vulnSignature == -1 or len(j["func"]) > CHAR_LIMIT:
                continue
            for k in filtered_data[i]["code"]:
                if k["target"] == 0 and getSignature(k["func"]) == vulnSignature:
                    testingData.append({"cwe": filtered_data[i]["cwe"][0], "desc": cwes[filtered_data[i]["cwe"][0]], "vuln": j["func"], "safe": k["func"]})

print(len(testingData))
random.shuffle(testingData)

# write the first item vuln and safe to file
# with open("example", "w") as f:
#     f.write(testingData[0]["vuln"])
#     f.write("\n")
#     f.write(testingData[0]["safe"])

tp = 0
tn = 0
fp = 0
fn = 0

for i in range(min(30, len(testingData))):
    
    ret = []
    for j in range(3):
        ret.append(isVulnerable(CWE, cwes[CWE], testingData[i]["vuln"]))
    # check if its unanimaous
    if len(set(ret)) == 1:
        if ret[0] == 1:
            tp += 1
        elif ret[0] == 0:
            fn += 1

    ret = []
    for j in range(3):
        ret.append(isVulnerable(CWE, cwes[CWE], testingData[i]["safe"]))
    # check if its unanimaous
    if len(set(ret)) != 1:
        if ret[0] == 1:
            fp += 1
        elif ret[0] == 0:
            tn += 1

    print(f"TP: {tp}, TN: {tn}, FP: {fp}, FN: {fn}")
    print(f"Cost: {calculateTotalCost(tokens)}")
