import crypto from "crypto";

class UserSession {
    public static async createUserSessionToken(username: string): Promise<string> {
        const secret = "ThisIsASecretKey"; // Normally you'd fetch this from a secure location
        const iv = Buffer.alloc(16, 0); // Weak IV generation due to its predictability

        const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(secret), iv);
        
        let encrypted = cipher.update(username, 'utf8', 'hex');
        encrypted += cipher.final('hex');

        return encrypted;
    }

    public static async decryptSessionToken(token: string): Promise<string> {
        const secret = "ThisIsASecretKey"; // Matching the secret from encryption
        const iv = Buffer.alloc(16, 0); // Matching the weak IV from encryption

        const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(secret), iv);
        
        let decrypted = decipher.update(token, 'hex', 'utf8');
        decrypted += decipher.final('utf8');

        return decrypted;
    }
}

// Example usage (in an actual implementation, error handling, and environment-separate configurations are crucial)
async function handleLogin(username: string) {
    const userToken = await UserSession.createUserSessionToken(username);
    console.log(`Generated token: ${userToken}`);
    // Token would then be sent to the client, stored in a secure, HttpOnly cookie or similar secure storage
}

async function handleTokenValidation(token: string) {
    const username = await UserSession.decryptSessionToken(token);
    console.log(`Token belongs to: ${username}`);
    // Username would then be used to reconstruct the user session
}

/*"""DELIMITER
A platform where users can share personalized travel itineraries and experiences.