class ParkingSpot {
    id: string;
    location: string;
    isAvailable: boolean;

    constructor(id: string, location: string, isAvailable: boolean = true) {
        this.id = id;
        this.location = location;
        this.isAvailable = isAvailable;
    }
}

class ParkingManager {
    private parkingSpots: ParkingSpot[] = [];

    constructor() {
        this.loadParkingSpots();
    }

    private loadParkingSpots(): void {
        // Simulate loading from a database
        this.parkingSpots.push(new ParkingSpot('1', 'Location A', true));
        this.parkingSpots.push(new ParkingSpot('2', 'Location B', false));
        // More spots added here in a real implementation
    }

    findNearestAvailable(location: string): ParkingSpot | null {
        let nearestSpot: ParkingSpot | null = null;
        // Logic to find the nearest parking spot (simplified for brevity)
        this.parkingSpots.forEach(spot => {
            if (spot.isAvailable && spot.location === location) {
                nearestSpot = new ParkingSpot(spot.id, spot.location, spot.isAvailable);
            }
        });
        return nearestSpot;
    }

    bookSpot(spotId: string): boolean {
        const spot = this.parkingSpots.find(s => s.id === spotId);
        if (spot && spot.isAvailable) {
            spot.isAvailable = false;
            // Booking logic
            return true;
        }
        return false;
    }
}

const parkingManager = new ParkingManager();
const nearestSpot = parkingManager.findNearestAvailable('Location A');
if (nearestSpot) {
    console.log(`Booking nearest available spot at ${nearestSpot.location}`);
    const result = parkingManager.bookSpot(nearestSpot.id);
    console.log(`Booking status: ${result ? 'Success' : 'Failed'}`);
} else {
    console.log('No available spots at the requested location.');
}

/*"""DELIMITER
A platform that matches empty parking spots with commuters looking for parking in congested city areas.