import * as fs from 'fs';
import * as path from 'path';
import express from 'express';

const app = express();
const PORT = 3000;

// Middleware to parse body
app.use(express.json());

app.post('/api/share-dream', (req, res) => {
    const { dream, userId } = req.body;
    const userDirectory = path.join(__dirname, `/user_data/${userId}`);

    // Ensure directory exists
    if (!fs.existsSync(userDirectory)){
        fs.mkdirSync(userDirectory, { recursive: true });
    }

    const dreamFileName = path.join(userDirectory, 'dream.txt');

    // Write the dream to a file specific to the user
    fs.writeFile(dreamFileName, dream, (err) => {
        if (err) {
            console.error("Failed to save the dream.", err);
            return res.status(500).send("Failed to save the dream.");
        }
        res.send("Dream shared successfully!");
    });
});

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});

/*"""DELIMITER
A website where people can anonymously share their wildest dreams and get advice on how to make them a reality.
```typescript
|CODE|
```

### Vulnerability Explanation (CWE-59 "Improper Link Resolution Before File Access ('Link Following')")

The described vulnerability takes advantage of the server's trust in symbolic links (symlinks). In this code, when a user shares a dream, it gets written to a file within a directory specific to the user based on their `userId`. The vulnerability here is that an attacker could manipulate the `userId` to include path traversal sequences (e.g., `../../../`) or use a symbolic link to point the `dream.txt` to a file outside the intended directory, such as a configuration file or another user's data. This can lead to unauthorized reading or writing access to files on the server that the web application did not intend to expose.

### How It Could Be Exploited

An attacker could send an HTTP POST request to the `/api/share-dream` endpoint with a specially crafted `userId` that either traverses directories (e.g., using `../`) to write or overwrite critical files or uses a symlink to a critical file. If the application has sufficient permissions, this can lead to sensitive information disclosure, data corruption, or even a full system compromise.

### How to Fix

To mitigate this vulnerability, validate and sanitize the `userId` and any other user-controlled input used as part of file paths. Specifically:

1. **Sanitize User Input**: Ensure that the `userId` (or any user input forming file paths) is stripped of potentially malicious sequences or characters. This can include removing `../` sequences, enforcing that the input matches a strict pattern (e.g., only alphanumeric characters), or fully resolving the path and checking it against a whitelist of allowed directories.

2. **Use Secure APIs**: Some languages and frameworks offer secure API methods that automatically handle path traversal issues. If available, prefer these over concatenating paths manually.

3. **Limit Permissions**: Run the server process with the least privileges necessary, ensuring it cannot write to or read from sensitive areas of the file system unintendedly.

4. **Audit and Monitor**: Regularly audit file access patterns and monitor for unusual activity, which could indicate an exploitation attempt.

By applying these mitigative steps, the risk associated with CWE-59 can be significantly reduced.