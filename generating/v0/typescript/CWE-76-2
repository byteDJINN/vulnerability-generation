import { Request, Response } from 'express';
import fs from 'fs';

const getRecipePage = (req: Request, res: Response) => {
    const recipeName: string = req.query.name;

    // Attempting to serve the recipe page directly from the filesystem
    const pagePath: string = `./recipes/${recipeName}.html`;

    fs.readFile(pagePath, 'utf8', (err, data) => {
        if (err) {
            res.status(404).send('Recipe not found.');
            return;
        }
        res.send(data);
    });
};

export default getRecipePage;

/*"""DELIMITER
A crowdsourced recipe platform for sharing and rating creations made with unconventional ingredient pairings.
```typescript
|CODE|
```

### Explanation of the CWE-76 Vulnerability

This vulnerability arises from the improper handling or sanitization of special elements, in this case, filesystem paths, which allows an attacker to traverse directories (also known as directory traversal). The code snippet above does not sanitize or validate the recipe name received from the query parameters before using it to construct a path to a local file. This approach can be exploited by an attacker who can manipulate the query parameter `name` to include special elements (../ or ..\\ depending on the operating system) to access files outside the intended directory.

### How It Could Be Exploited

An attacker could exploit this vulnerability by crafting a special URL that includes directory traversal sequences in the `name` query parameter. For example, if an attacker wanted to access a configuration file or another sensitive document outside the `./recipes/` directory, they might send a request like `https://example.com/getRecipePage?name=../../config`. This would cause the application to attempt to read a file from a directory two levels up from the intended one.

### How to Fix the Vulnerability

To prevent this kind of attack, we must validate and sanitize the input used to construct file paths. One straightforward approach is to ensure that the file name only contains characters that are valid for a recipe name and does not include path traversal sequences. Here's an example of how the `getRecipePage` function can be updated to mitigate this vulnerability:

```typescript
const getRecipePage = (req: Request, res: Response) => {
    let recipeName: string = req.query.name;

    // Validating and sanitizing the input to include only acceptable characters
    recipeName = recipeName.replace(/[^a-zA-Z0-9_\-]/g, '');

    const pagePath: string = `./recipes/${recipeName}.html`;

    fs.readFile(pagePath, 'utf8', (err, data) => {
        if (err) {
            res.status(404).send('Recipe not found.');
            return;
        }
        res.send(data);
    });
};
```
In this revised version, the recipe name is sanitized by removing any character that is not a letter, a number, an underscore, or a hyphen. This effectively prevents directory traversal by not allowing special filesystem characters such as `../` or `..\`. For more comprehensive protection, further steps such as checking against a list of known good file names or ensuring that the constructed path is within a specific directory could be implemented.