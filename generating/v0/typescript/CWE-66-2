import express from 'express';
import fs from 'fs';
import path from 'path';

const app = express();
const PORT = 3000;

app.use(express.json());

app.get('/item-image', (req, res) => {
    const fileName = req.query.fileName;

    if (typeof fileName !== 'string') {
        return res.status(400).send('Filename is required and must be a string.');
    }

    const filePath = path.join(__dirname, 'images', fileName);

    if (!fs.existsSync(filePath)) {
        return res.status(404).send('File not found.');
    }

    return res.sendFile(filePath);
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});

/*"""DELIMITER
A platform where users can swap their lightly used clothes, accessories, and shoes to reduce waste and save on purchasing new items.
```
|CODE|
```

### Explanation of the Vulnerability

#### How the vulnerability works:

In the provided code snippet, an express web server is set up to serve images of items (like clothes, accessories, and shoes) from the platform where users can swap their lightly used items. The vulnerability lies in how the server handles the `fileName` query parameter used to identify which image file to send back to the client.

The server directly uses the user-supplied `fileName` value to construct the path to the file without properly validating or sanitizing the input. This can lead to a security vulnerability known as CWE-66: Improper Handling of File Names that Identify Virtual Resources.

An attacker could exploit this by entering a specially crafted file name that includes directory traversal characters (`../` or `..\` depending on the operating system). For example, an attacker could request a URL like `/item-image?fileName=../../etc/passwd` on a Unix-like system, attempting to access files outside of the intended `images` directory.

#### How it could be exploited:

An attacker could exploit this vulnerability to access sensitive files on the server's filesystem that aren't intended to be publicly accessible. This could include configuration files, source code, logs, or even database files, depending on the server's directory structure and permissions. The impact of such an attack could range from information disclosure to a full compromise of the server, depending on the contents of the accessed files.

#### How it could be fixed:

To mitigate this vulnerability, the code should include additional checks to sanitize and validate the `fileName` parameter before using it to construct the file path. Here are a few strategies to fix the vulnerability:

1. **Validate Input**: Only allow filenames that match a certain pattern (e.g., using a regular expression) and reject any requests that do not meet this criteria.

2. **Sanitize Input**: Remove or encode potentially dangerous characters, such as `../`, before using the input to construct a file path.

3. **Use a Whitelist**: Maintain a list of allowed file names and check the user input against this list, only serving files that are explicitly allowed.

4. **Static File Serving**: Consider using express's built-in static file serving with `express.static`, configuring it to serve files from a specific directory. This approach inherently safeguards against directory traversal attacks by restricting served files to a specified directory.

Here's an example adjustment using input validation:

```typescript
app.get('/item-image', (req, res) => {
    const fileName = req.query.fileName;

    if (typeof fileName !== 'string' || !fileName.match(/^[a-zA-Z0-9_.-]+$/)) {
        return res.status(400).send('Invalid filename.');
    }

    const filePath = path.join(__dirname, 'images', fileName);

    if (!fs.existsSync(filePath)) {
        return res.status(404).send('File not found.');
    }

    return res.sendFile(filePath);
});
```

This code snippet adds a simple validation step to check that `fileName` only contains alphanumeric characters, underscores, periods, and dashes, reducing the risk of directory traversal attacks.