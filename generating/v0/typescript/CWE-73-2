import * as fs from 'fs';
import * as path from 'path';
import express from 'express';

const app = express();
app.use(express.json());

// Endpoint to download files like images of musical instruments
app.get('/download', (req, res) => {
    const fileName = req.query.fileName as string;

    const filePath = path.join(__dirname, 'uploads', fileName);

    fs.exists(filePath, (exists) => {
        if (exists) {
            res.download(filePath, (err) => {
                if (err) {
                    res.status(500).send("Error downloading the file.");
                }
            });
        } else {
            res.status(404).send("File not found.");
        }
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

/*"""DELIMITER
A platform where users can swap or sell musical instruments.
```typescript
|CODE|
```

### Explanation of the Vulnerability

The vulnerability here is CWE-73: External Control of File Name or Path. In the code above, the vulnerability arises from taking a filename directly from the user input (`req.query.fileName`) without proper validation or sanitation and directly using it to construct a file path (`path.join(__dirname, 'uploads', fileName)`). This can lead to several types of attacks, mainly Path Traversal attacks.

### How It Could Be Exploited

An attacker could exploit this vulnerability by crafting a request that includes "../" sequences in the `fileName` parameter. For example, an attacker could input something like `fileName=../../../../etc/passwd` in an attempt to trick the server into sending back the contents of the `/etc/passwd` file, which contains sensitive information about the system's users.

### How to Fix It

To fix this vulnerability, you need to ensure that the file paths are securely validated and sanitized before they are used. One way to do this is to check if the resolved path starts with the expected directory path. Additionally, you can maintain a list (or database) of valid file names and check the user input against this list before accessing the file. Hereâ€™s a modified snippet that includes this check:

```typescript
app.get('/download', (req, res) => {
    const fileName = req.query.fileName as string;

    const expectedBaseDir = path.join(__dirname, 'uploads');
    const filePath = path.resolve(expectedBaseDir, fileName);

    // Validate the resolved file path starts with the expected base directory
    if (!filePath.startsWith(expectedBaseDir)) {
        return res.status(400).send("Invalid file name.");
    }

    fs.exists(filePath, (exists) => {
        if (exists) {
            res.download(filePath, (err) => {
                if (err) {
                    res.status(500).send("Error downloading the file.");
                }
            });
        } else {
            res.status(404).send("File not found.");
        }
    });
});
```

In this fixed version, `path.resolve()` is used to get the absolute path which is then checked to ensure it starts with the `expectedBaseDir`. This helps ensure that the path traversal attacks are mitigated by refusing to process any request which resolves to a path outside the intended directory.