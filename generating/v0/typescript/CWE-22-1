import * as express from 'express';
import * as fs from 'fs';
import * as path from 'path';

const app = express();

// Middleware to serve static files
app.use('/static', express.static('public'));

app.get('/download/card-image', (req, res) => {
    const fileName = req.query.fileName as string;
    const filePath = path.join(__dirname, 'card-images', fileName);

    fs.readFile(filePath, (err, data) => {
        if (err) {
            res.status(404).send("File not found.");
            return;
        }
        res.setHeader('Content-Type', 'image/jpeg');
        res.send(data);
    });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

/*"""DELIMITER
A platform for organizing cards from various games, trading them with users, and learning strategies from a community of players.
```typescript
|CODE|
```

### Vulnerability Explanation

This code snippet has a vulnerability known as CWE-22, or "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')". It occurs in the `"GET /download/card-image"` route handler, where user input (specified by the `fileName` query parameter) is used directly to construct a file path. The application intends to serve image files from a designated directory (`'card-images'`), but due to insufficient input validation and sanitization, an attacker could exploit this by requesting a file path that navigates out of the intended directory.

### Exploitation

An attacker could exploit this vulnerability by crafting a special `fileName` that includes ".." sequences to traverse up the directory tree (`../`) and access files outside of the `'card-images'` directory. For instance, an attacker could request a URL like `/download/card-image?fileName=../../config/secrets.env` to attempt to access sensitive files stored elsewhere on the server.

### Fix

To mitigate this vulnerability, the application should:

1. **Sanitize input:** Ensure that the `fileName` parameter does not contain sequences like `../` that could lead to directory traversal. A simple method is to strip such sequences from the input or reject requests containing them.
2. **Validate input:** Check if the `fileName` corresponds to a known, expected format or list of files. Reject any requests that do not match expected patterns.
3. **Use a safe method to join paths:** Libraries like `path` provide functions (e.g., `path.resolve`, `path.join`) that can be used securely to construct paths. However, always proceed with caution and perform validations before their use.
4. **Limit file access:** Only allow access to certain file types (e.g., `.jpg`, `.png` for images) and deny requests for any other file types.
5. **Use a dedicated library for serving static files:** Whenever possible, rely on mature, widely-used libraries to serve static content. These libraries generally have built-in mitigations for common vulnerabilities, including path traversal.

Here's a simple input validation fix applied to the route handler:

```typescript
app.get('/download/card-image', (req, res) => {
    const fileName = req.query.fileName as string;
    // Basic sanitation to prevent path traversal
    if (fileName.indexOf('..') > -1) {
        res.status(400).send("Invalid file name.");
        return;
    }
    const filePath = path.join(__dirname, 'card-images', fileName);

    // Proceed with reading the file...
});
```

**Note:** This example implements a basic form of input sanitization. However, it's always recommended to use comprehensive security practices and libraries to ensure robust protection.