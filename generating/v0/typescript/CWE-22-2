import * as fs from 'fs';
import * as path from 'path';
import * as express from 'express';

const app = express();

app.get('/resources/:name', function(req, res) {
  const fileName = req.params.name;
  const resourcesPath = path.join(__dirname, 'resources');
  const filePath = path.join(resourcesPath, fileName);
  
  fs.readFile(filePath, function(err, data) {
    if (err) {
      res.status(404).send('Resource not found.');
    } else {
      res.contentType(path.extname(filePath));
      res.send(data);
    }
  });
});

app.listen(3000, function() {
  console.log('Server running on port 3000');
});

/*"""DELIMITER
A website that connects users to experienced tutors for personalized and interactive learning sessions.
```typescript
|CODE|
```

### Vulnerability Explanation:

This code snippet is designed to serve files from a specific `resources` directory based on user input in a website that connects users to experienced tutors. However, it contains a vulnerability related to CWE-22, "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')".

The vulnerability arises because the code directly concatenates user input (`req.params.name`) with a directory path (`resourcesPath`) to form `filePath` without sufficiently verifying or sanitizing the input. This makes it susceptible to path traversal attacks.

### Potential Exploit:

An attacker could exploit this vulnerability to access files outside the intended `resources` directory. For example, by requesting a URL like `/resources/../../etc/passwd`, an attacker could potentially retrieve system files or other sensitive information, assuming the server has improper permissions set up. This is because the `../` pattern can navigate directories up, escaping the intended directory.

### Resolution:

To mitigate this vulnerability, it is crucial to validate or sanitize the user input to ensure it does not contain sequences that could lead to path traversal. One approach is to remove or encode potentially dangerous characters (such as `..`) from the input before using it to form file paths. Additionally, one can use more secure libraries or functions designed to safely open files without allowing directory traversal.

Here's a basic example of how you could start fixing the vulnerability:

```typescript
app.get('/resources/:name', function(req, res) {
  const fileName = req.params.name;
  // Basic validation to remove '..' to prevent directory traversal
  const sanitizedFileName = fileName.replace(/\.\./g, '');
  const resourcesPath = path.join(__dirname, 'resources');
  const filePath = path.join(resourcesPath, sanitizedFileName);
  
  fs.readFile(filePath, function(err, data) {
    if (err) {
      res.status(404).send('Resource not found.');
    } else {
      res.contentType(path.extname(filePath));
      res.send(data);
    }
  });
});
```

However, this is a basic example. A more robust solution may involve checking that the resolved path starts with the intended directory path and using security libraries that offer utility functions for these purposes.