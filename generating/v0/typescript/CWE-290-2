import express from 'express';
import { Request, Response } from 'express';
import jwt from 'jsonwebtoken';

const app = express();
const port = 3000;

// Mock database
const users = {
  admin: { password: "admin123", role: "admin" },
  user1: { password: "user1pass", role: "user" }
};

// This simulates a typical authentication function that you might find in a real application.
// It has a critical vulnerability that can allow an attacker to bypass authentication.
app.post('/login', (req: Request, res: Response) => {
  const { username, password } = req.body;

  if (users[username] && users[username].password === password) {
    // Sign token with user information
    const token = jwt.sign({ username, role: users[username].role }, 'secret', { expiresIn: '1h' });

    res.json({ message: "Login successful", token });
  } else {
    res.status(401).json({ message: "Authentication failed" });
  }
});

// Endpoint to display global energy data. This data is supposed to be accessible only to authenticated users.
app.get('/energy-data', (req: Request, res: Response) => {
  const token = req.headers.authorization?.split(" ")[1];

  try {
    const decoded = jwt.verify(token, 'secret') as any;

    // The vulnerability lies here: an attacker could spoof the "role" claim in the JWT if they have knowledge of the secret or if the JWT implementation is flawed.
    // A secure approach should have additional checks here, such as verifying the user's role from a trusted source/database.
    if (decoded.role === "admin") {
      res.json({ message: "Displaying global energy data" });
    } else {
      res.status(403).json({ message: "Insufficient privileges" });
    }
  } catch (error) {
    res.status(401).json({ message: "Invalid or expired token" });
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});

/*"""DELIMITER
A website where users can track global energy use and conservation efforts on an interactive map.