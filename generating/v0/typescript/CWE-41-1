import * as fs from 'fs';
import * as path from 'path';
import express from 'express';

const app = express();
const PORT = 3000;

// Middleware to serve static assets
app.use('/public', express.static('public'));

app.get('/download-catalog', (req, res) => {
    let fileName = req.query.filename as string;
    
    // Path where catalogs are stored
    const catalogPath = path.join(__dirname, 'catalogs', fileName);

    fs.exists(catalogPath, (exists) => {
        if (exists) {
            res.sendFile(catalogPath);
        } else {
            res.status(404).send('Catalog not found.');
        }
    });
});

app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

/*"""DELIMITER
A marketplace that connects interior designers with My discovery-minded manufacturers for unique and bespoke home furnishings.
```typescript
|CODE|
```

### Vulnerability Explanation

This TypeScript code snippet sets up an Express server designed to serve static assets and provide a functionality to download product catalogs for an online marketplace that connects interior designers with manufacturers. The vulnerability lies in the `/download-catalog` route handler. The `fileName` parameter retrieved from the query string is directly concatenated with the path to the `catalogs` directory. This implementation does not check for or sanitize against directory traversal attacks, making it susceptible to the CWE-41: Improper Resolution of Path Equivalence vulnerability.

### How It Could Be Exploited

An attacker could exploit this vulnerability to access files outside of the intended `catalogs` directory. By using a crafted request with `../` sequences in the `filename` query parameter (e.g., `filename=../../../../etc/passwd`), an attacker could potentially traverse the directory upward out of the web application's root to the system's file directory, gaining unauthorized access to sensitive files on the server.

### How It Could Be Fixed

To fix this vulnerability, the application should validate and sanitize the input paths. It can utilize path normalization to resolve the `..` sequences and ensure the resulting path is within the intended directory. Additionally, checking explicitly against accessing files outside the designated folder would improve security. Hereâ€™s an improved version of the critical part:

```typescript
app.get('/download-catalog', (req, res) => {
    let fileName = req.query.filename as string;
    
    // Normalize the path to prevent directory traversal
    fileName = path.basename(fileName);

    // Construct the catalogPath with the sanitized filename
    const catalogPath = path.join(__dirname, 'catalogs', fileName);

    // Ensure the file exists and serve it
    fs.exists(catalogPath, (exists) => {
        if (exists) {
            res.sendFile(catalogPath);
        } else {
            res.status(404).send('Catalog not found.');
        }
    });
});
```

In this improved version, `path.basename()` is used to extract only the filename portion of the `fileName` parameter, removing any directory traversal attempts. This simple method prevents attackers from accessing files outside the intended `catalogs` directory, effectively mitigating the CWE-41 vulnerability.