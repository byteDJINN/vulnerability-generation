import * as fs from 'fs';
import * as path from 'path';
import express from 'express';

const app = express();
const PORT = 3000;

app.use(express.urlencoded({ extended: true }));

// Route to upload outfit images
app.post('/upload-outfit', (req, res) => {
  const { outfitName, imagePath } = req.body;
  
  const outputPath = path.join(__dirname, 'uploads', path.basename(imagePath));

  // Check if the outfitName is provided
  if (!outfitName) {
    return res.status(400).send('Outfit name is required.');
  }

  // Attempt to create a symbolic link for the uploaded outfit image
  fs.symlink(imagePath, outputPath, (err) => {
    if (err) {
      console.error(err);
      return res.status(500).send('Failed to upload outfit image.');
    }
    res.send('Outfit image uploaded successfully.');
  });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

/*"""DELIMITER
A platform where users can trade clothes by showing off outfits they’ve put together.
```typescript
|CODE|
```

### Explanation:

The vulnerability in the above code lies in the improper handling of symbolic links when creating a symlink for an uploaded outfit image. The vulnerability is identified as CWE-59: Improper Link Resolution Before File Access ('Link Following').

#### How the Vulnerability Works:
The code does not verify whether the `imagePath` (input provided by the user for the image location) is pointing to a legitimate file or is a symbolic link to a critical system file or directory. When `fs.symlink()` is used to create a symbolic link to the `imagePath`, it could potentially point to sensitive files. As a result, an attacker could craft a request with an `imagePath` that is a symbolic link to a sensitive file, leading to unauthorized access when the application tries to access or display the linked file.

#### How It Could Be Exploited:
An attacker could exploit this vulnerability by creating a symbolic link on their system to a sensitive file (e.g., `/etc/passwd`, system configuration files, etc.) and then sending the path to this symbolic link as the `imagePath` parameter. If the application logic uses or exposes the content of the linked file, this can lead to information disclosure, risking the confidentiality and integrity of the application and its data.

#### How It Could Be Fixed:
1. **Validate Input Paths**: Ensure that `imagePath` is validated to point only to intended directories or files. Reject paths that traverse directories (e.g., containing `..`) or any form of links.
2. **Secure File Upload Practices**: Implement secure file upload practices such as checking mimetypes, storing files in a dedicated directory with limited permissions, and never directly exposing file paths provided by users.
3. **Use Proper File Handling Mechanisms**: Instead of creating symbolic links to user-provided paths, directly copy the file to the server using secure copying functions that validate the file before saving. If symbolic links must be used, verify the target file’s integrity and authenticity.
4. **Access Control**: Ensure strict access control measures are in place, limiting what files can be accessed or linked based on the application's requirements and user permissions.

By addressing these points, the application can significantly reduce the risk associated with CWE-59 and ensure safer file handling operations.