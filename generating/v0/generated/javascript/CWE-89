const secretId = getRequestParameter('id');
const query = `SELECT * FROM Secrets WHERE id = ${secretId}`;
database.query(query, (err, result) => {
    if (err) {
        console.error('Error fetching secret:', err);
    } else {
        console.log('Secret details:', result);
    }
});

function getRequestParameter(parameter) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(parameter);
}

/*"""DELIMITER
```
|CODE|```

### Vulnerability Explanation:
The vulnerability in the code snippet is a SQL injection vulnerability due to the improper handling of user input in constructing the SQL query. The `secretId` parameter obtained from the `getRequestParameter` function is directly interpolated into the SQL query without any sanitization or validation. This allows an attacker to manipulate the `id` parameter in the URL to inject malicious SQL code into the query.

### Exploitation:
An attacker can exploit this vulnerability by manipulating the `id` parameter in the URL query string to inject SQL commands. For example, by setting `id` to `1 OR 1=1`, the resulting SQL query would become `SELECT * FROM Secrets WHERE id = 1 OR 1=1`, which would always return true and potentially expose confidential data or even delete records.

### Fix:
To prevent SQL injection attacks, it is recommended to use parameterized queries or prepared statements instead of directly concatenating user input into SQL queries. Parameterized queries separate the SQL code from the user input, thereby preventing the user input from being treated as part of the SQL command. In this case, the code should use parameterized queries to safely handle user input for filtering and querying the database.