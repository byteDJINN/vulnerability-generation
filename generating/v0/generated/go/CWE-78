package main

import (
	"fmt"
	"os/exec"
	"net/http"
)

func main() {
	http.HandleFunc("/submit", func(w http.ResponseWriter, r *http.Request) {
		cmd := exec.Command("echo", r.URL.Query().Get("submission"))
		output, err := cmd.Output()
		if err != nil {
			fmt.Fprintf(w, "An error occurred")
			return
		}
		fmt.Fprintf(w, "Submitted: %s", output)
	})

	http.ListenAndServe(":8080", nil)
}

/*"""DELIMITER
```
|CODE|```

Explanation:
The code snippet contains a command injection vulnerability due to the improper handling of user input when constructing the shell command. In this case, the code takes user input from the URL query parameter "submission" and directly passes it to the `exec.Command` function without proper validation or sanitization.

Exploitation:
An attacker could craft a malicious URL by appending shell commands to the "submission" query parameter. For example, a malicious URL like `http://example.com/submit?submission=;ls` would execute the `ls` command on the server, leading to potential unauthorized information disclosure or even system compromise.

Fix:
To prevent command injection vulnerabilities, it is important to properly sanitize and validate user input before incorporating it into a shell command. In this case, you should use input validation and sanitization techniques, such as whitelisting acceptable characters or using parameterized queries, to ensure that only intended input is executed as part of the command. Additionally, consider using a safe method like `os/exec` to execute shell commands securely.