import sqlite3

# Vulnerable code snippet
def get_secret_by_id(secret_id):
    conn = sqlite3.connect('secrets.db')
    cursor = conn.cursor()
    query = f"SELECT content FROM secrets WHERE id = {secret_id}"
    cursor.execute(query)
    secret = cursor.fetchone()
    conn.close()
    return secret

/*"""DELIMITER
```
|CODE|```

Explanation of vulnerability:
In the provided code snippet, the `get_secret_by_id()` function dynamically constructs an SQL query using string interpolation to fetch a secret based on the provided `secret_id` parameter. This is vulnerable to SQL injection because the `secret_id` variable could be maliciously crafted by an attacker to inject arbitrary SQL commands into the query.

Exploitation:
An attacker could input a malicious `secret_id` value such as `1; DROP TABLE secrets; --` to perform a SQL injection attack. This would result in the execution of an additional SQL command to drop the `secrets` table from the database, leading to data loss.

Fix:
To prevent SQL injection attacks, it is recommended to use parameterized queries or prepared statements instead of directly concatenating user input into SQL queries. By using parameterized queries, the SQL engine will treat the input as data rather than executable code, effectively mitigating the SQL injection vulnerability.

An improved version of the code snippet with parameterized query would look like the following:
```
def get_secret_by_id(secret_id):
    conn = sqlite3.connect('secrets.db')
    cursor = conn.cursor()
    query = "SELECT content FROM secrets WHERE id = ?"
    cursor.execute(query, (secret_id,))
    secret = cursor.fetchone()
    conn.close()
    return secret
```