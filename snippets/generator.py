import os
import random
import re
from dotenv import load_dotenv

from openai import OpenAI

load_dotenv()


class VulnerabilityGenerator:
    def __init__(self, apiKey, directory="generated"):
        self.client = OpenAI(api_key=apiKey)
        self.directory = directory
        self.technologies = [
            "JavaScript", "HTML", "Python", "SQL", "TypeScript", "Bash", "Java", "C#", "C++", "C",
            "PHP", "PowerShell", "Go", "Rust", "Kotlin", "Ruby", "Lua", "Dart", "Assembly", "Swift",
            "R", "Visual Basic (.Net)", "MATLAB", "VBA", "Groovy", "Delphi", "Scala", "Perl", "Elixir",
            "Objective-C", "Haskell", "GDScript", "Lisp", "Solidity", "Clojure", "Julia", "Erlang",
            "F#", "Fortran", "Prolog", "Zig", "Ada", "OCaml", "Apex", "Cobol", "SAS", "Crystal", "Nim",
            "APL", "Flow", "Raku"
        ][:14]
        self.totalTokens = 0

    def generateCodeSnippet(self, technology, vulnerabilityName, vulnerabilityDesc, websiteIdea):
        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "You are a developer who writes code snippets and accidentally left in the specified vulnerability.",
                },
                {
                    "role": "user",
                    "content": f"""
                        Write a code snippet for the following website using {technology} that contains the vulnerability {vulnerabilityName} {vulnerabilityDesc}.
                        The code snippet should be enclosed in triple backticks. After the code snippet, write an explanation of how the vulnerability works, how it could be exploited, and how it could be fixed.
                        The code should be realistic, it should not be obvious there is a vulnerability. It should look like real code found on a real github repository for an actual live website. 
                        The code should be for a website about: {websiteIdea}
                    """ 
                }
            ],
            temperature=1,
            stop=[],
        )
        codeSnippet = re.search(r"```.*?\n(.*?)```", response.choices[0].message.content, re.DOTALL).group(1)
        codeExplanation = response.choices[0].message.content.replace(codeSnippet, "|CODE|\n")

        self.totalTokens += response.usage.total_tokens

        _directory = f"{self.directory}/{technology.lower()}"
        os.makedirs(_directory, exist_ok=True)
        with open(f"{_directory}/{vulnerabilityName}", "w") as file:
            file.write(codeSnippet)
            file.write("\n/*\"\"\"DELIMITER\n")
            file.write(codeExplanation)

    def getValidTechnologies(self, vulnerabilityName, vulnerabilityDesc):
        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "user",
                    "content": f"""
                        Given a list of technologies, output each technology on a line followed by a space and a 1 or 0 indicating if the vulnerability {vulnerabilityName} {vulnerabilityDesc} could exist inside an application that uses the given language.
                        After each technology, write a one sentence explanation of why you made that decision on the following line.
                        Do not make overarching statements regarding all languages. Make an individual decision per language.
                        Always be on the safe side, even if the vulnerability is unlikely, if it is possible, mark it as 1.
                        The only exception is if the language is not capable of the vulnerability, then mark it as 0.
                        {chr(10).join(self.technologies)}
                    """,
                }
            ],
            temperature=0,
            stop=[],
        )
        validTechnologiesResponse = response.choices[0].message.content

        self.totalTokens += response.usage.total_tokens

        with open(f"{self.directory}/validTechnologies", "w") as file:
            file.write(validTechnologiesResponse)

        validTechnologies = [t for t in self.technologies if re.search(f"{re.escape(t)} 1", validTechnologiesResponse)]
        return validTechnologies

    def generateWebsiteIdea(self):
        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "user",
                    "content": "Give me a random idea for a website in one sentence",
                }
            ],
            temperature=1.7,
            stop=[],
        )
        websiteIdea = response.choices[0].message.content

        self.totalTokens += response.usage.total_tokens

        with open(f"{self.directory}/websiteIdea", "w") as file:
            file.write(websiteIdea)

        return websiteIdea

    def generateVulnerabilities(self, vulnerabilityName, vulnerabilityDesc):
        websiteIdea = self.generateWebsiteIdea()
        validTechnologies = self.getValidTechnologies(vulnerabilityName, vulnerabilityDesc)

        for technology in validTechnologies:
            self.generateCodeSnippet(technology, vulnerabilityName, vulnerabilityDesc, websiteIdea)
    
    def calculateTotalCost(self):
        # Assuming the price per 1,000 tokens for gpt-3.5-turbo is $0.002
        pricePerToken = 0.002 / 1000
        totalCost = self.totalTokens * pricePerToken
        return totalCost


if __name__ == "__main__":
    load_dotenv()
    apiKey = os.getenv("OPENAI_API_KEY")
    generator = VulnerabilityGenerator(apiKey)

    with open("699.csv", "r") as file:
        lines = file.readlines()
        for line in lines[11:20]:
            vulnerabilityID, vulnerabilityName = line.strip().split(",")[0:2]
            generator.generateVulnerabilities(f"CWE-{vulnerabilityID}", vulnerabilityName)
            totalCost = generator.calculateTotalCost()
            print(f"Total cost: ${totalCost:.4f}")