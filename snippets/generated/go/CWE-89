package main

import (
    "database/sql"
    "fmt"
    "net/http"

    _ "github.com/go-sql-driver/mysql"
)

var db *sql.DB

func main() {
    http.HandleFunc("/secrets", getSecrets)
    http.ListenAndServe(":8080", nil)
}

func getSecrets(w http.ResponseWriter, r *http.Request) {
    secretID := r.URL.Query().Get("secretID")
    
    query := fmt.Sprintf("SELECT secret FROM secrets WHERE id = %s", secretID)
    rows, err := db.Query(query)
    if err != nil {
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        return
    }
    defer rows.Close()

    for rows.Next() {
        var secret string
        err := rows.Scan(&secret)
        if err != nil {
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }
        fmt.Fprintf(w, "Secret: %s\n", secret)
    }
}

/*"""DELIMITER
```
|CODE|```

In the above code snippet, the vulnerability lies in the `getSecrets` function where the `secretID` parameter obtained from the request URL query is directly interpolated into the SQL query without any sanitization or validation. This allows for SQL Injection attacks where an attacker can manipulate the `secretID` parameter to execute arbitrary SQL queries.

For example, an attacker could craft a URL like `http://website.com/secrets?secretID=1%20OR%201=1` which would result in the SQL query becoming `SELECT secret FROM secrets WHERE id = 1 OR 1=1` leading to all secrets being returned instead of a specific one.

To fix this vulnerability, it is crucial to use parameterized queries or prepared statements to sanitize user inputs before executing SQL queries. By parameterizing the query, the user input will be treated as data and not as a part of the SQL command, effectively preventing SQL Injection attacks. 

Here is an updated version of the vulnerable code with a parameterized query:
```go
func getSecrets(w http.ResponseWriter, r *http.Request) {
    secretID := r.URL.Query().Get("secretID")
    
    query := "SELECT secret FROM secrets WHERE id = ?"
    rows, err := db.Query(query, secretID)
    if err != nil {
        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
        return
    }
  
    defer rows.Close()

    for rows.Next() {
        var secret string
        err := rows.Scan(&secret)
        if err != nil {
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }
        fmt.Fprintf(w, "Secret: %s\n", secret)
    }
}
```