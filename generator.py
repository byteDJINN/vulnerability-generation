import os
import random
import re
from dotenv import load_dotenv

from openai import OpenAI

load_dotenv()


class VulnerabilityGenerator:
    def __init__(self, apiKey, directory="generated"):
        self.client = OpenAI(api_key=apiKey)
        self.directory = directory
        self.technologies = [
           # "Python", "TypeScript", "Java", "C#", "C++", "PHP"
           "TypeScript"
        ]
        self.totalTokens = 0
        self.websiteIdea = ""

    def generateCodeSnippet(self, technology, vulnerabilityName, vulnerabilityDesc):
        response = self.client.chat.completions.create(
            model="gpt-4-0125-preview",
            messages=[
                {
                    "role": "system",
                    "content": "You are a developer who writes code snippets and accidentally left in the specified vulnerability.",
                },
                {
                    "role": "user",
                    "content": f"""
                        Write a code snippet for the following website using {technology} that contains the vulnerability {vulnerabilityName} {vulnerabilityDesc}.
                        The code snippet should be enclosed in triple backticks. Do not write anything else other than the code snippet.
                        The code should be realistic, it should not be obvious there is a vulnerability. It should look like real code found on a real github repository for an actual live website. 
                        The code should be for a website about: {self.websiteIdea}
                    """ 
                }
            ],
            temperature=1,
            stop=[],
        )
        codeSnippet = re.search(r"```.*?\n(.*?)```", response.choices[0].message.content, re.DOTALL)
        if codeSnippet is None:
            print("No code snippet found")
            return
        codeSnippet = codeSnippet.group(1)
        codeExplanation = self.websiteIdea #+ "\n" + response.choices[0].message.content.replace(codeSnippet, "|CODE|\n")

        self.totalTokens += response.usage.total_tokens

        _directory = f"{self.directory}/{technology.lower()}"
        os.makedirs(_directory, exist_ok=True)
        # if file already exists, increment name
        i = 1
        while os.path.exists(f"{_directory}/{vulnerabilityName}-{i}"):
            i += 1
        with open(f"{_directory}/{vulnerabilityName}-{i}", "w") as file:
            file.write(codeSnippet)
            file.write("\n/*\"\"\"DELIMITER\n")
            file.write(codeExplanation)

    def getValidTechnologies(self, vulnerabilityName, vulnerabilityDesc):
        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "user",
                    "content": f"""
                        Given a list of technologies, output each technology on a line followed by a space and a 1 or 0 indicating if the vulnerability {vulnerabilityName} {vulnerabilityDesc} could exist inside an application that uses the given language.
                        After each technology, write a one sentence explanation of why you made that decision on the following line.
                        Do not make overarching statements regarding all languages. Make an individual decision per language.
                        Always be on the safe side, even if the vulnerability is unlikely, if it is possible, mark it as 1.
                        The only exception is if the language is not capable of the vulnerability, then mark it as 0.
                        {chr(10).join(self.technologies)}
                    """,
                }
            ],
            temperature=0,
            stop=[],
        )
        validTechnologiesResponse = response.choices[0].message.content

        self.totalTokens += response.usage.total_tokens

        os.makedirs(f"{self.directory}/validTechnologies", exist_ok=True)
        with open(f"{self.directory}/validTechnologies/{vulnerabilityName}", "w") as file:
            file.write(validTechnologiesResponse)

        validTechnologies = [t for t in self.technologies if re.search(f"{re.escape(t)} 1", validTechnologiesResponse)]
        return validTechnologies

    def generateWebsiteIdea(self):
        response = self.client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "user",
                    "content": "Give me a random idea for a website in one sentence",
                }
            ],
            temperature=1.7,
            stop=[],
        )
        self.websiteIdea = response.choices[0].message.content
        self.totalTokens += response.usage.total_tokens


    def generateVulnerabilities(self, vulnerabilityName, vulnerabilityDesc):
        self.generateWebsiteIdea()
        #validTechnologies = self.getValidTechnologies(vulnerabilityName, vulnerabilityDesc)

        #for technology in validTechnologies:
        for technology in self.technologies:
            self.generateCodeSnippet(technology, vulnerabilityName, vulnerabilityDesc)
    
    def calculateTotalCost(self):
        # Assuming price upper limit
        # price is either 0.002 or 0.01
        pricePerToken = 0.01 / 1000
        totalCost = self.totalTokens * pricePerToken
        return totalCost


if __name__ == "__main__":
    load_dotenv()
    apiKey = os.getenv("OPENAI_API_KEY")
    generator = VulnerabilityGenerator(apiKey)

    with open("699.csv", "r") as file:
        lines = file.readlines()
        lines = lines[1:]
        for line in lines:
            vulnerabilityID, vulnerabilityName = line.strip().split(",")[0:2]
            for i in range(2):
                generator.generateVulnerabilities(f"CWE-{vulnerabilityID}", vulnerabilityName)
                totalCost = generator.calculateTotalCost()
                print(f"Total cost: ${totalCost:.4f}")